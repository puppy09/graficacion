import * as i0 from '@angular/core';
import { EventEmitter, Component, Input, Output, ViewChild, Injectable } from '@angular/core';
import * as go from 'gojs';
import { produce } from 'immer';

/**
 * Defines some shared helper static functions, used in Diagram / Palette / Overview Components
 */
class NgDiagramHelper {
    constructor() { }
    /**
     * Ensures mousemove event listeners on a diagram's canvas are run outside NgZone.
     * This way, change detection isn't triggered on each mousemove, improving performance.
     *
     * If some state-alteration must happen on a mousemove event inside the diagram, use zone.run() to make sure the event triggers angular change detection.
     * Used by DiagramComponent, PaletteComponent, and OverviewComponent in their ngAfterViewInit lifecycle hooks
     * @param diagram
     * @param zone
     */
    static makeMouseMoveRunOutsideAngularZone(diagram, zone) {
        diagram.addEventListener = (DOMElement, name, listener, capture) => {
            const superAddEventListener = go.Diagram.prototype.addEventListener;
            if (name === 'mousemove') {
                zone.runOutsideAngular(() => superAddEventListener.call(this, DOMElement, name, listener, capture));
            }
            else {
                zone.run(() => {
                    superAddEventListener.call(this, DOMElement, name, listener, capture);
                });
            }
        };
    }
    /**
     * Initialize a given diagram's model with given node / link / model data
     * @param diagram
     * @param nodeDataArray
     * @param linkDataArray
     * @param modelData
     */
    static initializeModel(diagram, nodeDataArray, linkDataArray, modelData) {
        diagram.delayInitialization(() => {
            const model = diagram.model;
            model.commit((m) => {
                if (modelData) {
                    m.assignAllDataProperties(m.modelData, modelData);
                }
                m.mergeNodeDataArray(m.cloneDeep(nodeDataArray));
                if (linkDataArray && m instanceof go.GraphLinksModel) {
                    m.mergeLinkDataArray(m.cloneDeep(linkDataArray));
                }
            }, null);
        });
    }
    /**
     * Initialize the model changed listener for the Palette / Diagram of a given compoennt; ensure it runs inside the component's ngZone.
     * Those changes will be emitted through a the component's modelChange EventEmitter.
     * @param component
     */
    static initializeModelChangedListener(component) {
        var diagram = null;
        if (!(component.hasOwnProperty("diagram")) && !(component.hasOwnProperty("palette")))
            return;
        if (component.hasOwnProperty("diagram"))
            diagram = component["diagram"];
        if (component.hasOwnProperty("palette"))
            diagram = component["palette"];
        component.modelChangedListener = (e) => {
            if (e.isTransactionFinished && e.model && !e.model.isReadOnly && component.modelChange) {
                // this must be done within a NgZone.run block, so changes are detected in the parent component
                component.zone.run(() => {
                    const dataChanges = e.model.toIncrementalData(e);
                    if (dataChanges !== null)
                        component.modelChange.emit(dataChanges);
                });
            }
        };
        diagram.addModelChangedListener(component.modelChangedListener);
    }
    /**
     * Merge the app-level node / link / model data of a supplied Diagram|Palette Component with its underlying Diagram|Palette model data
     * @param component
     * @param isInit Whether or not to treat this update as a Diagram initialization
     */
    static mergeAppDataWithModel(component, isInit) {
        var diagram = null;
        if (component.hasOwnProperty("diagram"))
            diagram = component["diagram"];
        if (component.hasOwnProperty("palette"))
            diagram = component["palette"];
        diagram.model.commit((m) => {
            if (isInit)
                diagram.model.modelData = {};
            // update modelData first, in case bindings on nodes / links depend on model data
            diagram.model.assignAllDataProperties(diagram.model.modelData, component.modelData);
            // merge node / link data
            if (isInit)
                diagram.model.nodeDataArray = [];
            diagram.model.mergeNodeDataArray(component.nodeDataArray);
            if (component.linkDataArray && diagram.model instanceof go.GraphLinksModel) {
                if (isInit)
                    diagram.model.linkDataArray = [];
                diagram.model.mergeLinkDataArray(component.linkDataArray);
            }
        }, isInit ? null : 'update data');
    }
}

class DiagramComponent {
    zone;
    /**
     * Diagram initialization function. Returns a go.Diagram.
     * Do not initialize model data in this function.
     */
    initDiagram;
    /**  Node data for diagram */
    nodeDataArray;
    /**  Link data for diagram. Optional. */
    linkDataArray = null;
    /** Model data for diagram. Optional. */
    modelData = null;
    /** Diagram div class name. Use this name to style your diagram in CSS. */
    divClassName;
    /** Model changed listener function for diagram */
    modelChangedListener = null;
    /** Whether or not to skip merging app data with GoJS model data (set to true if update is coming from GoJS, false if coming from app-level, usually) */
    skipsDiagramUpdate = false;
    /** Event emitter -- fires when diagram model changes. Capture this emitted event in parent component */
    modelChange = new EventEmitter();
    /** The DIV element holding the Diagram */
    diagramDiv;
    /** The Diagram itself */
    diagram = null;
    /** An internal flag used to tell ngOnChanges to treat the next sync operation as a Diagram initialization */
    wasCleared = false;
    constructor(zone) {
        this.zone = zone;
    }
    /**
     * Initializes diagram / model after view init
     */
    ngAfterViewInit() {
        if (!this.diagramDiv) {
            throw new Error('diagramDiv is not defined');
        }
        this.diagram = this.initDiagram();
        if (!(this.diagram instanceof go.Diagram)) {
            throw new Error('initDiagram function did not return a go.Diagram');
        }
        // reduces change detection on mouse moves, boosting performance
        NgDiagramHelper.makeMouseMoveRunOutsideAngularZone(this.diagram, this.zone);
        // assign the Diagram's div, which (among many other things) will attach a bunch of listeners to the canvas,
        // using the overridden addEventListener function defined in makeMouseMoveRunOutsideAngularZone
        const divRef = this.diagramDiv.nativeElement;
        if (divRef === null)
            return;
        this.diagram.div = divRef;
        // initialize the diagram model with the provided node / link / model data
        NgDiagramHelper.initializeModel(this.diagram, this.nodeDataArray, this.linkDataArray, this.modelData);
        // initializer model listener
        NgDiagramHelper.initializeModelChangedListener(this);
    } // end ngAfterViewInit
    /**
     * If a change has occurred on an @Input property, merge the app-level changes with GoJS
     */
    ngOnChanges() {
        if (!this.diagram || !this.diagram.model || this.skipsDiagramUpdate)
            return;
        // if clear was just called, treat this as initial
        if (this.wasCleared) {
            this.diagram.delayInitialization(() => {
                NgDiagramHelper.mergeAppDataWithModel(this, true);
            });
            this.wasCleared = false;
        }
        else {
            NgDiagramHelper.mergeAppDataWithModel(this);
        }
    } // end ngOnChanges
    /**
     * Clears the diagram of all nodes, links, and model data.
     * Also clears the UndoManager history and clipboard.
     * The next state update will be treated as diagram initialization.
     */
    clear() {
        const diagram = this.diagram;
        if (diagram !== null) {
            diagram.clear();
            this.wasCleared = true;
        }
    } // end clear function
    /**
     * Set this.diagram.div to null, removing all event listeners
     */
    ngOnDestroy() {
        this.diagram.div = null; // removes event listeners
    } // end ngOnDestroy function
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.4", ngImport: i0, type: DiagramComponent, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.1.4", type: DiagramComponent, isStandalone: true, selector: "gojs-diagram", inputs: { initDiagram: "initDiagram", nodeDataArray: "nodeDataArray", linkDataArray: "linkDataArray", modelData: "modelData", divClassName: "divClassName", skipsDiagramUpdate: "skipsDiagramUpdate" }, outputs: { modelChange: "modelChange" }, viewQueries: [{ propertyName: "diagramDiv", first: true, predicate: ["ngDiagram"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: '<div #ngDiagram [className]=divClassName></div>', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.4", ngImport: i0, type: DiagramComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'gojs-diagram',
                    template: '<div #ngDiagram [className]=divClassName></div>',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: i0.NgZone }], propDecorators: { initDiagram: [{
                type: Input
            }], nodeDataArray: [{
                type: Input
            }], linkDataArray: [{
                type: Input
            }], modelData: [{
                type: Input
            }], divClassName: [{
                type: Input
            }], skipsDiagramUpdate: [{
                type: Input
            }], modelChange: [{
                type: Output
            }], diagramDiv: [{
                type: ViewChild,
                args: ['ngDiagram', { static: true }]
            }] } });

class PaletteComponent {
    zone;
    /**
     * Palette initialization function. Returns a go.Palette.
     * Do not initialize model data in this function.
     */
    initPalette;
    /** Node data for palette */
    nodeDataArray;
    /** Link data for palette. Optional. */
    linkDataArray = null;
    /** Model data for palette. Optional. */
    modelData = null;
    /** Palette div class name. Use this name to style your palette in CSS */
    divClassName;
    /** Event emitter -- fires when palette model changes. Capture this emitted event in parent component */
    modelChange = new EventEmitter();
    /** The DIV element holding the Palette */
    paletteDiv;
    /** The Palette itself */
    palette = null;
    constructor(zone) {
        this.zone = zone;
    }
    /**
     * Initialize Palette after view init
     */
    ngAfterViewInit() {
        if (!this.paletteDiv) {
            throw new Error('paletteDiv is not defined');
        }
        this.palette = this.initPalette();
        if (!(this.palette instanceof go.Palette)) {
            throw new Error('initPalette function did not return a go.Palette');
        }
        // reduces change detection on mouse moves, boosting performance
        NgDiagramHelper.makeMouseMoveRunOutsideAngularZone(this.palette, this.zone);
        // assign the Palette's div, which (among many other things) will attach a bunch of listeners to the canvas,
        // using the overridden addEventListener function above
        const divRef = this.paletteDiv.nativeElement;
        if (divRef == null)
            return;
        this.palette.div = divRef;
        // initialize palette model
        NgDiagramHelper.initializeModel(this.palette, this.nodeDataArray, this.linkDataArray, this.modelData);
    }
    /**
     * If a change has occured on an @Input property, merge the app-level changes with GoJS
     */
    ngOnChanges() {
        if (!this.palette || !this.palette.model)
            return;
        NgDiagramHelper.mergeAppDataWithModel(this);
    } // end ngOnChanges
    ngOnDestroy() {
        this.palette.div = null; // removes event listeners
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.4", ngImport: i0, type: PaletteComponent, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.1.4", type: PaletteComponent, isStandalone: true, selector: "gojs-palette", inputs: { initPalette: "initPalette", nodeDataArray: "nodeDataArray", linkDataArray: "linkDataArray", modelData: "modelData", divClassName: "divClassName" }, outputs: { modelChange: "modelChange" }, viewQueries: [{ propertyName: "paletteDiv", first: true, predicate: ["ngPalette"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: '<div #ngPalette [className]=divClassName></div>', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.4", ngImport: i0, type: PaletteComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'gojs-palette',
                    template: '<div #ngPalette [className]=divClassName></div>',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: i0.NgZone }], propDecorators: { initPalette: [{
                type: Input
            }], nodeDataArray: [{
                type: Input
            }], linkDataArray: [{
                type: Input
            }], modelData: [{
                type: Input
            }], divClassName: [{
                type: Input
            }], modelChange: [{
                type: Output
            }], paletteDiv: [{
                type: ViewChild,
                args: ['ngPalette', { static: true }]
            }] } });

class OverviewComponent {
    zone;
    /** The function used to initialize and return the Overview */
    initOverview;
    /** The div class name that holds the Overview. Use this name to style your Overview in CSS. */
    divClassName;
    /** The Diagram to observe with the Overview */
    observedDiagram = null;
    overviewDiv;
    /** The Overview itself  */
    overview = null;
    constructor(zone) {
        this.zone = zone;
    }
    /**
     * Initialize the overview
     */
    ngAfterViewInit() {
        if (!this.overviewDiv) {
            throw new Error('overviewDiv is not defined');
        }
        if (this.initOverview) {
            this.overview = this.initOverview();
            if (!(this.overview instanceof go.Overview)) {
                throw new Error('initOverview function did not return a go.Overview');
            }
        }
        else {
            this.overview = new go.Overview();
            this.overview.contentAlignment = go.Spot.Center;
        }
        // reduces change detection on mouse moves, boosting performance
        NgDiagramHelper.makeMouseMoveRunOutsideAngularZone(this.overview, this.zone);
        this.overview.div = this.overviewDiv.nativeElement;
    }
    /**
     * Only update when the observed diagram changes
     * @param changes
     */
    ngOnChanges(changes) {
        if (!this.overview)
            return;
        if (changes &&
            changes['observedDiagram'] &&
            changes['observedDiagram'].currentValue !==
                changes['observedDiagram'].previousValue) {
            this.overview.observed = changes['observedDiagram'].currentValue;
        }
    }
    ngOnDestroy() {
        this.overview.div = null; // removes event listeners
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.4", ngImport: i0, type: OverviewComponent, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.1.4", type: OverviewComponent, isStandalone: true, selector: "gojs-overview", inputs: { initOverview: "initOverview", divClassName: "divClassName", observedDiagram: "observedDiagram" }, viewQueries: [{ propertyName: "overviewDiv", first: true, predicate: ["ngOverview"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: '<div #ngOverview [className]=divClassName></div>', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.4", ngImport: i0, type: OverviewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'gojs-overview',
                    template: '<div #ngOverview [className]=divClassName></div>',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: i0.NgZone }], propDecorators: { initOverview: [{
                type: Input
            }], divClassName: [{
                type: Input
            }], observedDiagram: [{
                type: Input
            }], overviewDiv: [{
                type: ViewChild,
                args: ['ngOverview', { static: true }]
            }] } });

class DataSyncService {
    /**
     * Sync a node data array with a set of changes
     * @param changes The set of changes to the GoJS model
     * @param nodeData The node data array to merge these changes with
     * @param model Required if you have defined your model.nodeKeyProperty to be something other than 'key'
     * @returns A node data array, merged with the changes
     */
    static syncNodeData(changes, nodeData, model) {
        if (!changes)
            return nodeData;
        if (!changes.modifiedNodeData &&
            !changes.insertedNodeKeys &&
            !changes.removedNodeKeys)
            return nodeData;
        // maintain a map of modified nodes for fast lookup during insertion
        const modifiedNodesMap = new go.Map();
        // generate a map of keys -> indices for faster operations
        const keyIdxMap = new Map();
        nodeData.forEach((nd, idx) => {
            const key = model ? model.getKeyForNodeData(nd) : nd['key'];
            keyIdxMap.set(key, idx);
        });
        // nodeData is immutable, modify it using the immer package's "produce" function (creates new array)
        var newNodeDataArray = produce(nodeData, (draft) => {
            // account for modified node data
            if (changes.modifiedNodeData) {
                changes.modifiedNodeData.forEach((nd) => {
                    // Get the value of the node key property checking wether is a function or a string
                    const key = model ? model.getKeyForNodeData(nd) : nd['key'];
                    modifiedNodesMap.set(key, nd);
                    const idx = keyIdxMap.get(key);
                    if (idx !== undefined && idx >= 0) {
                        draft[idx] = nd;
                    }
                });
            }
            // account for inserted node data
            if (changes.insertedNodeKeys) {
                changes.insertedNodeKeys.forEach((key) => {
                    const nd = modifiedNodesMap.get(key);
                    if (nd && !keyIdxMap.has(key)) {
                        draft.push(nd);
                    }
                });
            }
            // account for removed node data
            if (changes.removedNodeKeys) {
                const removals = changes.removedNodeKeys.map((key) => keyIdxMap.get(key));
                removals.sort((a, b) => a - b);
                for (let i = removals.length - 1; i >= 0; i--) {
                    const idx = removals[i];
                    if (idx !== undefined)
                        draft.splice(idx, 1);
                }
            }
        });
        return newNodeDataArray;
    }
    /**
     * Sync a link data array with a set of changes
     * @param changes The set of changes to the GoJS model
     * @param linkData The link data array to merge these changes with
     * @param model Required if you have defined your model.linkKeyProperty to be something other than 'key'
     * @returns A link data array, merged with the changes
     */
    static syncLinkData(changes, linkData, model) {
        if (!changes)
            return linkData;
        if (!changes.modifiedLinkData &&
            !changes.insertedLinkKeys &&
            !changes.removedLinkKeys)
            return linkData;
        // maintain a map of modified nodes for fast lookup during insertion
        const modifiedLinksMap = new go.Map();
        // generate a map of keys -> indices for faster operations
        const keyIdxMap = new Map();
        linkData.forEach((ld, idx) => {
            const key = model ? model.getKeyForLinkData(ld) : ld['key'];
            keyIdxMap.set(key, idx);
        });
        // linkData is immutable, modify it using the immer package's "produce" function (creates new array)
        linkData = produce(linkData, (draft) => {
            // account for modified link data
            if (changes.modifiedLinkData) {
                changes.modifiedLinkData.forEach((ld) => {
                    // Get the value of the link key
                    const key = model ? model.getKeyForLinkData(ld) : ld['key'];
                    modifiedLinksMap.set(key, ld);
                    const idx = keyIdxMap.get(key);
                    if (idx !== undefined && idx >= 0) {
                        draft[idx] = ld;
                    }
                });
            }
            // account for inserted link data
            if (changes.insertedLinkKeys) {
                changes.insertedLinkKeys.forEach((key) => {
                    const nd = modifiedLinksMap.get(key);
                    if (nd && !keyIdxMap.has(key)) {
                        draft.push(nd);
                    }
                });
            }
            // account for removed link data
            if (changes.removedLinkKeys) {
                const removals = changes.removedLinkKeys.map((key) => keyIdxMap.get(key));
                removals.sort((a, b) => a - b);
                for (let i = removals.length - 1; i >= 0; i--) {
                    draft.splice(removals[i], 1);
                }
            }
        });
        return linkData;
    }
    /**
     * Sync modelData with a set of changes
     * @param changes The set of changes to the GoJS model
     * @param modelData The modelData to merge these changes with
     * @returns A modelData object, merged with the changes
     */
    static syncModelData(changes, modelData) {
        if (!changes)
            return modelData;
        if (!changes.modelData)
            return modelData;
        if (changes.modelData) {
            return changes.modelData;
        }
        return modelData;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.4", ngImport: i0, type: DataSyncService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.4", ngImport: i0, type: DataSyncService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.4", ngImport: i0, type: DataSyncService, decorators: [{
            type: Injectable
        }] });

/*
 * Public API Surface of gojs-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DataSyncService, DiagramComponent, OverviewComponent, PaletteComponent };
//# sourceMappingURL=gojs-angular.mjs.map
